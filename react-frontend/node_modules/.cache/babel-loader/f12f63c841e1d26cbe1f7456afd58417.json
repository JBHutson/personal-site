{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/jameshutson/Code/jameshutson_v2.0/personal-site/react-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";\nimport _toConsumableArray from \"/Users/jameshutson/Code/jameshutson_v2.0/personal-site/react-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _slicedToArray from \"/Users/jameshutson/Code/jameshutson_v2.0/personal-site/react-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _classCallCheck from \"/Users/jameshutson/Code/jameshutson_v2.0/personal-site/react-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/jameshutson/Code/jameshutson_v2.0/personal-site/react-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport DateTime, { friendlyDateTime } from \"./datetime.js\";\nimport Duration, { friendlyDuration } from \"./duration.js\";\nimport Settings from \"./settings.js\";\nimport { InvalidArgumentError, InvalidIntervalError } from \"./errors.js\";\nimport Invalid from \"./impl/invalid.js\";\nvar INVALID = \"Invalid Interval\"; // checks if the start is equal to or before the end\n\nfunction validateStartEnd(start, end) {\n  if (!start || !start.isValid) {\n    return Interval.invalid(\"missing or invalid start\");\n  } else if (!end || !end.isValid) {\n    return Interval.invalid(\"missing or invalid end\");\n  } else if (end < start) {\n    return Interval.invalid(\"end before start\", \"The end of an interval must be after its start, but you had start=\".concat(start.toISO(), \" and end=\").concat(end.toISO()));\n  } else {\n    return null;\n  }\n}\n/**\n * An Interval object represents a half-open interval of time, where each endpoint is a {@link DateTime}. Conceptually, it's a container for those two endpoints, accompanied by methods for creating, parsing, interrogating, comparing, transforming, and formatting them.\n *\n * Here is a brief overview of the most commonly used methods and getters in Interval:\n *\n * * **Creation** To create an Interval, use {@link fromDateTimes}, {@link after}, {@link before}, or {@link fromISO}.\n * * **Accessors** Use {@link start} and {@link end} to get the start and end.\n * * **Interrogation** To analyze the Interval, use {@link count}, {@link length}, {@link hasSame}, {@link contains}, {@link isAfter}, or {@link isBefore}.\n * * **Transformation** To create other Intervals out of this one, use {@link set}, {@link splitAt}, {@link splitBy}, {@link divideEqually}, {@link merge}, {@link xor}, {@link union}, {@link intersection}, or {@link difference}.\n * * **Comparison** To compare this Interval to another one, use {@link equals}, {@link overlaps}, {@link abutsStart}, {@link abutsEnd}, {@link engulfs}.\n * * **Output** To convert the Interval into other representations, see {@link toString}, {@link toISO}, {@link toISODate}, {@link toISOTime}, {@link toFormat}, and {@link toDuration}.\n */\n\n\nvar Interval = /*#__PURE__*/function () {\n  /**\n   * @private\n   */\n  function Interval(config) {\n    _classCallCheck(this, Interval);\n\n    /**\n     * @access private\n     */\n    this.s = config.start;\n    /**\n     * @access private\n     */\n\n    this.e = config.end;\n    /**\n     * @access private\n     */\n\n    this.invalid = config.invalid || null;\n    /**\n     * @access private\n     */\n\n    this.isLuxonInterval = true;\n  }\n  /**\n   * Create an invalid Interval.\n   * @param {string} reason - simple string of why this Interval is invalid. Should not contain parameters or anything else data-dependent\n   * @param {string} [explanation=null] - longer explanation, may include parameters and other useful debugging information\n   * @return {Interval}\n   */\n\n\n  _createClass(Interval, [{\n    key: \"length\",\n\n    /**\n     * Returns the length of the Interval in the specified unit.\n     * @param {string} unit - the unit (such as 'hours' or 'days') to return the length in.\n     * @return {number}\n     */\n    value: function length() {\n      var unit = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"milliseconds\";\n      return this.isValid ? this.toDuration.apply(this, [unit]).get(unit) : NaN;\n    }\n    /**\n     * Returns the count of minutes, hours, days, months, or years included in the Interval, even in part.\n     * Unlike {@link length} this counts sections of the calendar, not periods of time, e.g. specifying 'day'\n     * asks 'what dates are included in this interval?', not 'how many days long is this interval?'\n     * @param {string} [unit='milliseconds'] - the unit of time to count.\n     * @return {number}\n     */\n\n  }, {\n    key: \"count\",\n    value: function count() {\n      var unit = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"milliseconds\";\n      if (!this.isValid) return NaN;\n      var start = this.start.startOf(unit),\n          end = this.end.startOf(unit);\n      return Math.floor(end.diff(start, unit).get(unit)) + 1;\n    }\n    /**\n     * Returns whether this Interval's start and end are both in the same unit of time\n     * @param {string} unit - the unit of time to check sameness on\n     * @return {boolean}\n     */\n\n  }, {\n    key: \"hasSame\",\n    value: function hasSame(unit) {\n      return this.isValid ? this.isEmpty() || this.e.minus(1).hasSame(this.s, unit) : false;\n    }\n    /**\n     * Return whether this Interval has the same start and end DateTimes.\n     * @return {boolean}\n     */\n\n  }, {\n    key: \"isEmpty\",\n    value: function isEmpty() {\n      return this.s.valueOf() === this.e.valueOf();\n    }\n    /**\n     * Return whether this Interval's start is after the specified DateTime.\n     * @param {DateTime} dateTime\n     * @return {boolean}\n     */\n\n  }, {\n    key: \"isAfter\",\n    value: function isAfter(dateTime) {\n      if (!this.isValid) return false;\n      return this.s > dateTime;\n    }\n    /**\n     * Return whether this Interval's end is before the specified DateTime.\n     * @param {DateTime} dateTime\n     * @return {boolean}\n     */\n\n  }, {\n    key: \"isBefore\",\n    value: function isBefore(dateTime) {\n      if (!this.isValid) return false;\n      return this.e <= dateTime;\n    }\n    /**\n     * Return whether this Interval contains the specified DateTime.\n     * @param {DateTime} dateTime\n     * @return {boolean}\n     */\n\n  }, {\n    key: \"contains\",\n    value: function contains(dateTime) {\n      if (!this.isValid) return false;\n      return this.s <= dateTime && this.e > dateTime;\n    }\n    /**\n     * \"Sets\" the start and/or end dates. Returns a newly-constructed Interval.\n     * @param {Object} values - the values to set\n     * @param {DateTime} values.start - the starting DateTime\n     * @param {DateTime} values.end - the ending DateTime\n     * @return {Interval}\n     */\n\n  }, {\n    key: \"set\",\n    value: function set() {\n      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          start = _ref.start,\n          end = _ref.end;\n\n      if (!this.isValid) return this;\n      return Interval.fromDateTimes(start || this.s, end || this.e);\n    }\n    /**\n     * Split this Interval at each of the specified DateTimes\n     * @param {...[DateTime]} dateTimes - the unit of time to count.\n     * @return {[Interval]}\n     */\n\n  }, {\n    key: \"splitAt\",\n    value: function splitAt() {\n      var _this = this;\n\n      if (!this.isValid) return [];\n\n      for (var _len = arguments.length, dateTimes = new Array(_len), _key = 0; _key < _len; _key++) {\n        dateTimes[_key] = arguments[_key];\n      }\n\n      var sorted = dateTimes.map(friendlyDateTime).filter(function (d) {\n        return _this.contains(d);\n      }).sort(),\n          results = [];\n      var s = this.s,\n          i = 0;\n\n      while (s < this.e) {\n        var added = sorted[i] || this.e,\n            next = +added > +this.e ? this.e : added;\n        results.push(Interval.fromDateTimes(s, next));\n        s = next;\n        i += 1;\n      }\n\n      return results;\n    }\n    /**\n     * Split this Interval into smaller Intervals, each of the specified length.\n     * Left over time is grouped into a smaller interval\n     * @param {Duration|Object|number} duration - The length of each resulting interval.\n     * @return {[Interval]}\n     */\n\n  }, {\n    key: \"splitBy\",\n    value: function splitBy(duration) {\n      var dur = friendlyDuration(duration);\n\n      if (!this.isValid || !dur.isValid || dur.as(\"milliseconds\") === 0) {\n        return [];\n      }\n\n      var s = this.s,\n          added,\n          next;\n      var results = [];\n\n      while (s < this.e) {\n        added = s.plus(dur);\n        next = +added > +this.e ? this.e : added;\n        results.push(Interval.fromDateTimes(s, next));\n        s = next;\n      }\n\n      return results;\n    }\n    /**\n     * Split this Interval into the specified number of smaller intervals.\n     * @param {number} numberOfParts - The number of Intervals to divide the Interval into.\n     * @return {[Interval]}\n     */\n\n  }, {\n    key: \"divideEqually\",\n    value: function divideEqually(numberOfParts) {\n      if (!this.isValid) return [];\n      return this.splitBy(this.length() / numberOfParts).slice(0, numberOfParts);\n    }\n    /**\n     * Return whether this Interval overlaps with the specified Interval\n     * @param {Interval} other\n     * @return {boolean}\n     */\n\n  }, {\n    key: \"overlaps\",\n    value: function overlaps(other) {\n      return this.e > other.s && this.s < other.e;\n    }\n    /**\n     * Return whether this Interval's end is adjacent to the specified Interval's start.\n     * @param {Interval} other\n     * @return {boolean}\n     */\n\n  }, {\n    key: \"abutsStart\",\n    value: function abutsStart(other) {\n      if (!this.isValid) return false;\n      return +this.e === +other.s;\n    }\n    /**\n     * Return whether this Interval's start is adjacent to the specified Interval's end.\n     * @param {Interval} other\n     * @return {boolean}\n     */\n\n  }, {\n    key: \"abutsEnd\",\n    value: function abutsEnd(other) {\n      if (!this.isValid) return false;\n      return +other.e === +this.s;\n    }\n    /**\n     * Return whether this Interval engulfs the start and end of the specified Interval.\n     * @param {Interval} other\n     * @return {boolean}\n     */\n\n  }, {\n    key: \"engulfs\",\n    value: function engulfs(other) {\n      if (!this.isValid) return false;\n      return this.s <= other.s && this.e >= other.e;\n    }\n    /**\n     * Return whether this Interval has the same start and end as the specified Interval.\n     * @param {Interval} other\n     * @return {boolean}\n     */\n\n  }, {\n    key: \"equals\",\n    value: function equals(other) {\n      if (!this.isValid || !other.isValid) {\n        return false;\n      }\n\n      return this.s.equals(other.s) && this.e.equals(other.e);\n    }\n    /**\n     * Return an Interval representing the intersection of this Interval and the specified Interval.\n     * Specifically, the resulting Interval has the maximum start time and the minimum end time of the two Intervals.\n     * Returns null if the intersection is empty, meaning, the intervals don't intersect.\n     * @param {Interval} other\n     * @return {Interval}\n     */\n\n  }, {\n    key: \"intersection\",\n    value: function intersection(other) {\n      if (!this.isValid) return this;\n      var s = this.s > other.s ? this.s : other.s,\n          e = this.e < other.e ? this.e : other.e;\n\n      if (s > e) {\n        return null;\n      } else {\n        return Interval.fromDateTimes(s, e);\n      }\n    }\n    /**\n     * Return an Interval representing the union of this Interval and the specified Interval.\n     * Specifically, the resulting Interval has the minimum start time and the maximum end time of the two Intervals.\n     * @param {Interval} other\n     * @return {Interval}\n     */\n\n  }, {\n    key: \"union\",\n    value: function union(other) {\n      if (!this.isValid) return this;\n      var s = this.s < other.s ? this.s : other.s,\n          e = this.e > other.e ? this.e : other.e;\n      return Interval.fromDateTimes(s, e);\n    }\n    /**\n     * Merge an array of Intervals into a equivalent minimal set of Intervals.\n     * Combines overlapping and adjacent Intervals.\n     * @param {[Interval]} intervals\n     * @return {[Interval]}\n     */\n\n  }, {\n    key: \"difference\",\n\n    /**\n     * Return an Interval representing the span of time in this Interval that doesn't overlap with any of the specified Intervals.\n     * @param {...Interval} intervals\n     * @return {[Interval]}\n     */\n    value: function difference() {\n      var _this2 = this;\n\n      for (var _len2 = arguments.length, intervals = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        intervals[_key2] = arguments[_key2];\n      }\n\n      return Interval.xor([this].concat(intervals)).map(function (i) {\n        return _this2.intersection(i);\n      }).filter(function (i) {\n        return i && !i.isEmpty();\n      });\n    }\n    /**\n     * Returns a string representation of this Interval appropriate for debugging.\n     * @return {string}\n     */\n\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      if (!this.isValid) return INVALID;\n      return \"[\".concat(this.s.toISO(), \" \\u2013 \").concat(this.e.toISO(), \")\");\n    }\n    /**\n     * Returns an ISO 8601-compliant string representation of this Interval.\n     * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals\n     * @param {Object} opts - The same options as {@link DateTime.toISO}\n     * @return {string}\n     */\n\n  }, {\n    key: \"toISO\",\n    value: function toISO(opts) {\n      if (!this.isValid) return INVALID;\n      return \"\".concat(this.s.toISO(opts), \"/\").concat(this.e.toISO(opts));\n    }\n    /**\n     * Returns an ISO 8601-compliant string representation of date of this Interval.\n     * The time components are ignored.\n     * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals\n     * @return {string}\n     */\n\n  }, {\n    key: \"toISODate\",\n    value: function toISODate() {\n      if (!this.isValid) return INVALID;\n      return \"\".concat(this.s.toISODate(), \"/\").concat(this.e.toISODate());\n    }\n    /**\n     * Returns an ISO 8601-compliant string representation of time of this Interval.\n     * The date components are ignored.\n     * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals\n     * @param {Object} opts - The same options as {@link DateTime.toISO}\n     * @return {string}\n     */\n\n  }, {\n    key: \"toISOTime\",\n    value: function toISOTime(opts) {\n      if (!this.isValid) return INVALID;\n      return \"\".concat(this.s.toISOTime(opts), \"/\").concat(this.e.toISOTime(opts));\n    }\n    /**\n     * Returns a string representation of this Interval formatted according to the specified format string.\n     * @param {string} dateFormat - the format string. This string formats the start and end time. See {@link DateTime.toFormat} for details.\n     * @param {Object} opts - options\n     * @param {string} [opts.separator =  ' – '] - a separator to place between the start and end representations\n     * @return {string}\n     */\n\n  }, {\n    key: \"toFormat\",\n    value: function toFormat(dateFormat) {\n      var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n          _ref2$separator = _ref2.separator,\n          separator = _ref2$separator === void 0 ? \" – \" : _ref2$separator;\n\n      if (!this.isValid) return INVALID;\n      return \"\".concat(this.s.toFormat(dateFormat)).concat(separator).concat(this.e.toFormat(dateFormat));\n    }\n    /**\n     * Return a Duration representing the time spanned by this interval.\n     * @param {string|string[]} [unit=['milliseconds']] - the unit or units (such as 'hours' or 'days') to include in the duration.\n     * @param {Object} opts - options that affect the creation of the Duration\n     * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use\n     * @example Interval.fromDateTimes(dt1, dt2).toDuration().toObject() //=> { milliseconds: 88489257 }\n     * @example Interval.fromDateTimes(dt1, dt2).toDuration('days').toObject() //=> { days: 1.0241812152777778 }\n     * @example Interval.fromDateTimes(dt1, dt2).toDuration(['hours', 'minutes']).toObject() //=> { hours: 24, minutes: 34.82095 }\n     * @example Interval.fromDateTimes(dt1, dt2).toDuration(['hours', 'minutes', 'seconds']).toObject() //=> { hours: 24, minutes: 34, seconds: 49.257 }\n     * @example Interval.fromDateTimes(dt1, dt2).toDuration('seconds').toObject() //=> { seconds: 88489.257 }\n     * @return {Duration}\n     */\n\n  }, {\n    key: \"toDuration\",\n    value: function toDuration(unit, opts) {\n      if (!this.isValid) {\n        return Duration.invalid(this.invalidReason);\n      }\n\n      return this.e.diff(this.s, unit, opts);\n    }\n    /**\n     * Run mapFn on the interval start and end, returning a new Interval from the resulting DateTimes\n     * @param {function} mapFn\n     * @return {Interval}\n     * @example Interval.fromDateTimes(dt1, dt2).mapEndpoints(endpoint => endpoint.toUTC())\n     * @example Interval.fromDateTimes(dt1, dt2).mapEndpoints(endpoint => endpoint.plus({ hours: 2 }))\n     */\n\n  }, {\n    key: \"mapEndpoints\",\n    value: function mapEndpoints(mapFn) {\n      return Interval.fromDateTimes(mapFn(this.s), mapFn(this.e));\n    }\n  }, {\n    key: \"start\",\n\n    /**\n     * Returns the start of the Interval\n     * @type {DateTime}\n     */\n    get: function get() {\n      return this.isValid ? this.s : null;\n    }\n    /**\n     * Returns the end of the Interval\n     * @type {DateTime}\n     */\n\n  }, {\n    key: \"end\",\n    get: function get() {\n      return this.isValid ? this.e : null;\n    }\n    /**\n     * Returns whether this Interval's end is at least its start, meaning that the Interval isn't 'backwards'.\n     * @type {boolean}\n     */\n\n  }, {\n    key: \"isValid\",\n    get: function get() {\n      return this.invalidReason === null;\n    }\n    /**\n     * Returns an error code if this Interval is invalid, or null if the Interval is valid\n     * @type {string}\n     */\n\n  }, {\n    key: \"invalidReason\",\n    get: function get() {\n      return this.invalid ? this.invalid.reason : null;\n    }\n    /**\n     * Returns an explanation of why this Interval became invalid, or null if the Interval is valid\n     * @type {string}\n     */\n\n  }, {\n    key: \"invalidExplanation\",\n    get: function get() {\n      return this.invalid ? this.invalid.explanation : null;\n    }\n  }], [{\n    key: \"invalid\",\n    value: function invalid(reason) {\n      var explanation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n      if (!reason) {\n        throw new InvalidArgumentError(\"need to specify a reason the Interval is invalid\");\n      }\n\n      var invalid = reason instanceof Invalid ? reason : new Invalid(reason, explanation);\n\n      if (Settings.throwOnInvalid) {\n        throw new InvalidIntervalError(invalid);\n      } else {\n        return new Interval({\n          invalid: invalid\n        });\n      }\n    }\n    /**\n     * Create an Interval from a start DateTime and an end DateTime. Inclusive of the start but not the end.\n     * @param {DateTime|Date|Object} start\n     * @param {DateTime|Date|Object} end\n     * @return {Interval}\n     */\n\n  }, {\n    key: \"fromDateTimes\",\n    value: function fromDateTimes(start, end) {\n      var builtStart = friendlyDateTime(start),\n          builtEnd = friendlyDateTime(end);\n      var validateError = validateStartEnd(builtStart, builtEnd);\n\n      if (validateError == null) {\n        return new Interval({\n          start: builtStart,\n          end: builtEnd\n        });\n      } else {\n        return validateError;\n      }\n    }\n    /**\n     * Create an Interval from a start DateTime and a Duration to extend to.\n     * @param {DateTime|Date|Object} start\n     * @param {Duration|Object|number} duration - the length of the Interval.\n     * @return {Interval}\n     */\n\n  }, {\n    key: \"after\",\n    value: function after(start, duration) {\n      var dur = friendlyDuration(duration),\n          dt = friendlyDateTime(start);\n      return Interval.fromDateTimes(dt, dt.plus(dur));\n    }\n    /**\n     * Create an Interval from an end DateTime and a Duration to extend backwards to.\n     * @param {DateTime|Date|Object} end\n     * @param {Duration|Object|number} duration - the length of the Interval.\n     * @return {Interval}\n     */\n\n  }, {\n    key: \"before\",\n    value: function before(end, duration) {\n      var dur = friendlyDuration(duration),\n          dt = friendlyDateTime(end);\n      return Interval.fromDateTimes(dt.minus(dur), dt);\n    }\n    /**\n     * Create an Interval from an ISO 8601 string.\n     * Accepts `<start>/<end>`, `<start>/<duration>`, and `<duration>/<end>` formats.\n     * @param {string} text - the ISO string to parse\n     * @param {Object} [opts] - options to pass {@link DateTime.fromISO} and optionally {@link Duration.fromISO}\n     * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals\n     * @return {Interval}\n     */\n\n  }, {\n    key: \"fromISO\",\n    value: function fromISO(text, opts) {\n      var _split = (text || \"\").split(\"/\", 2),\n          _split2 = _slicedToArray(_split, 2),\n          s = _split2[0],\n          e = _split2[1];\n\n      if (s && e) {\n        var start, startIsValid;\n\n        try {\n          start = DateTime.fromISO(s, opts);\n          startIsValid = start.isValid;\n        } catch (e) {\n          startIsValid = false;\n        }\n\n        var end, endIsValid;\n\n        try {\n          end = DateTime.fromISO(e, opts);\n          endIsValid = end.isValid;\n        } catch (e) {\n          endIsValid = false;\n        }\n\n        if (startIsValid && endIsValid) {\n          return Interval.fromDateTimes(start, end);\n        }\n\n        if (startIsValid) {\n          var dur = Duration.fromISO(e, opts);\n\n          if (dur.isValid) {\n            return Interval.after(start, dur);\n          }\n        } else if (endIsValid) {\n          var _dur = Duration.fromISO(s, opts);\n\n          if (_dur.isValid) {\n            return Interval.before(end, _dur);\n          }\n        }\n      }\n\n      return Interval.invalid(\"unparsable\", \"the input \\\"\".concat(text, \"\\\" can't be parsed as ISO 8601\"));\n    }\n    /**\n     * Check if an object is an Interval. Works across context boundaries\n     * @param {object} o\n     * @return {boolean}\n     */\n\n  }, {\n    key: \"isInterval\",\n    value: function isInterval(o) {\n      return o && o.isLuxonInterval || false;\n    }\n  }, {\n    key: \"merge\",\n    value: function merge(intervals) {\n      var _intervals$sort$reduc = intervals.sort(function (a, b) {\n        return a.s - b.s;\n      }).reduce(function (_ref3, item) {\n        var _ref4 = _slicedToArray(_ref3, 2),\n            sofar = _ref4[0],\n            current = _ref4[1];\n\n        if (!current) {\n          return [sofar, item];\n        } else if (current.overlaps(item) || current.abutsStart(item)) {\n          return [sofar, current.union(item)];\n        } else {\n          return [sofar.concat([current]), item];\n        }\n      }, [[], null]),\n          _intervals$sort$reduc2 = _slicedToArray(_intervals$sort$reduc, 2),\n          found = _intervals$sort$reduc2[0],\n          final = _intervals$sort$reduc2[1];\n\n      if (final) {\n        found.push(final);\n      }\n\n      return found;\n    }\n    /**\n     * Return an array of Intervals representing the spans of time that only appear in one of the specified Intervals.\n     * @param {[Interval]} intervals\n     * @return {[Interval]}\n     */\n\n  }, {\n    key: \"xor\",\n    value: function xor(intervals) {\n      var _Array$prototype;\n\n      var start = null,\n          currentCount = 0;\n\n      var results = [],\n          ends = intervals.map(function (i) {\n        return [{\n          time: i.s,\n          type: \"s\"\n        }, {\n          time: i.e,\n          type: \"e\"\n        }];\n      }),\n          flattened = (_Array$prototype = Array.prototype).concat.apply(_Array$prototype, _toConsumableArray(ends)),\n          arr = flattened.sort(function (a, b) {\n        return a.time - b.time;\n      });\n\n      var _iterator = _createForOfIteratorHelper(arr),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var i = _step.value;\n          currentCount += i.type === \"s\" ? 1 : -1;\n\n          if (currentCount === 1) {\n            start = i.time;\n          } else {\n            if (start && +start !== +i.time) {\n              results.push(Interval.fromDateTimes(start, i.time));\n            }\n\n            start = null;\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      return Interval.merge(results);\n    }\n  }]);\n\n  return Interval;\n}();\n\nexport { Interval as default };","map":{"version":3,"sources":["/Users/jameshutson/Code/jameshutson_v2.0/personal-site/react-frontend/node_modules/luxon/src/interval.js"],"names":["DateTime","friendlyDateTime","Duration","friendlyDuration","Settings","InvalidArgumentError","InvalidIntervalError","Invalid","INVALID","validateStartEnd","start","end","isValid","Interval","invalid","toISO","config","s","e","isLuxonInterval","unit","toDuration","get","NaN","startOf","Math","floor","diff","isEmpty","minus","hasSame","valueOf","dateTime","fromDateTimes","dateTimes","sorted","map","filter","d","contains","sort","results","i","added","next","push","duration","dur","as","plus","numberOfParts","splitBy","length","slice","other","equals","intervals","xor","concat","intersection","opts","toISODate","toISOTime","dateFormat","separator","toFormat","invalidReason","mapFn","reason","explanation","throwOnInvalid","builtStart","builtEnd","validateError","dt","text","split","startIsValid","fromISO","endIsValid","after","before","o","a","b","reduce","item","sofar","current","overlaps","abutsStart","union","found","final","currentCount","ends","time","type","flattened","Array","prototype","arr","merge"],"mappings":"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","sourcesContent":["import DateTime, { friendlyDateTime } from \"./datetime.js\";\nimport Duration, { friendlyDuration } from \"./duration.js\";\nimport Settings from \"./settings.js\";\nimport { InvalidArgumentError, InvalidIntervalError } from \"./errors.js\";\nimport Invalid from \"./impl/invalid.js\";\n\nconst INVALID = \"Invalid Interval\";\n\n// checks if the start is equal to or before the end\nfunction validateStartEnd(start, end) {\n  if (!start || !start.isValid) {\n    return Interval.invalid(\"missing or invalid start\");\n  } else if (!end || !end.isValid) {\n    return Interval.invalid(\"missing or invalid end\");\n  } else if (end < start) {\n    return Interval.invalid(\n      \"end before start\",\n      `The end of an interval must be after its start, but you had start=${start.toISO()} and end=${end.toISO()}`\n    );\n  } else {\n    return null;\n  }\n}\n\n/**\n * An Interval object represents a half-open interval of time, where each endpoint is a {@link DateTime}. Conceptually, it's a container for those two endpoints, accompanied by methods for creating, parsing, interrogating, comparing, transforming, and formatting them.\n *\n * Here is a brief overview of the most commonly used methods and getters in Interval:\n *\n * * **Creation** To create an Interval, use {@link fromDateTimes}, {@link after}, {@link before}, or {@link fromISO}.\n * * **Accessors** Use {@link start} and {@link end} to get the start and end.\n * * **Interrogation** To analyze the Interval, use {@link count}, {@link length}, {@link hasSame}, {@link contains}, {@link isAfter}, or {@link isBefore}.\n * * **Transformation** To create other Intervals out of this one, use {@link set}, {@link splitAt}, {@link splitBy}, {@link divideEqually}, {@link merge}, {@link xor}, {@link union}, {@link intersection}, or {@link difference}.\n * * **Comparison** To compare this Interval to another one, use {@link equals}, {@link overlaps}, {@link abutsStart}, {@link abutsEnd}, {@link engulfs}.\n * * **Output** To convert the Interval into other representations, see {@link toString}, {@link toISO}, {@link toISODate}, {@link toISOTime}, {@link toFormat}, and {@link toDuration}.\n */\nexport default class Interval {\n  /**\n   * @private\n   */\n  constructor(config) {\n    /**\n     * @access private\n     */\n    this.s = config.start;\n    /**\n     * @access private\n     */\n    this.e = config.end;\n    /**\n     * @access private\n     */\n    this.invalid = config.invalid || null;\n    /**\n     * @access private\n     */\n    this.isLuxonInterval = true;\n  }\n\n  /**\n   * Create an invalid Interval.\n   * @param {string} reason - simple string of why this Interval is invalid. Should not contain parameters or anything else data-dependent\n   * @param {string} [explanation=null] - longer explanation, may include parameters and other useful debugging information\n   * @return {Interval}\n   */\n  static invalid(reason, explanation = null) {\n    if (!reason) {\n      throw new InvalidArgumentError(\"need to specify a reason the Interval is invalid\");\n    }\n\n    const invalid = reason instanceof Invalid ? reason : new Invalid(reason, explanation);\n\n    if (Settings.throwOnInvalid) {\n      throw new InvalidIntervalError(invalid);\n    } else {\n      return new Interval({ invalid });\n    }\n  }\n\n  /**\n   * Create an Interval from a start DateTime and an end DateTime. Inclusive of the start but not the end.\n   * @param {DateTime|Date|Object} start\n   * @param {DateTime|Date|Object} end\n   * @return {Interval}\n   */\n  static fromDateTimes(start, end) {\n    const builtStart = friendlyDateTime(start),\n      builtEnd = friendlyDateTime(end);\n\n    const validateError = validateStartEnd(builtStart, builtEnd);\n\n    if (validateError == null) {\n      return new Interval({\n        start: builtStart,\n        end: builtEnd\n      });\n    } else {\n      return validateError;\n    }\n  }\n\n  /**\n   * Create an Interval from a start DateTime and a Duration to extend to.\n   * @param {DateTime|Date|Object} start\n   * @param {Duration|Object|number} duration - the length of the Interval.\n   * @return {Interval}\n   */\n  static after(start, duration) {\n    const dur = friendlyDuration(duration),\n      dt = friendlyDateTime(start);\n    return Interval.fromDateTimes(dt, dt.plus(dur));\n  }\n\n  /**\n   * Create an Interval from an end DateTime and a Duration to extend backwards to.\n   * @param {DateTime|Date|Object} end\n   * @param {Duration|Object|number} duration - the length of the Interval.\n   * @return {Interval}\n   */\n  static before(end, duration) {\n    const dur = friendlyDuration(duration),\n      dt = friendlyDateTime(end);\n    return Interval.fromDateTimes(dt.minus(dur), dt);\n  }\n\n  /**\n   * Create an Interval from an ISO 8601 string.\n   * Accepts `<start>/<end>`, `<start>/<duration>`, and `<duration>/<end>` formats.\n   * @param {string} text - the ISO string to parse\n   * @param {Object} [opts] - options to pass {@link DateTime.fromISO} and optionally {@link Duration.fromISO}\n   * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals\n   * @return {Interval}\n   */\n  static fromISO(text, opts) {\n    const [s, e] = (text || \"\").split(\"/\", 2);\n    if (s && e) {\n      let start, startIsValid;\n      try {\n        start = DateTime.fromISO(s, opts);\n        startIsValid = start.isValid;\n      } catch (e) {\n        startIsValid = false;\n      }\n\n      let end, endIsValid;\n      try {\n        end = DateTime.fromISO(e, opts);\n        endIsValid = end.isValid;\n      } catch (e) {\n        endIsValid = false;\n      }\n\n      if (startIsValid && endIsValid) {\n        return Interval.fromDateTimes(start, end);\n      }\n\n      if (startIsValid) {\n        const dur = Duration.fromISO(e, opts);\n        if (dur.isValid) {\n          return Interval.after(start, dur);\n        }\n      } else if (endIsValid) {\n        const dur = Duration.fromISO(s, opts);\n        if (dur.isValid) {\n          return Interval.before(end, dur);\n        }\n      }\n    }\n    return Interval.invalid(\"unparsable\", `the input \"${text}\" can't be parsed as ISO 8601`);\n  }\n\n  /**\n   * Check if an object is an Interval. Works across context boundaries\n   * @param {object} o\n   * @return {boolean}\n   */\n  static isInterval(o) {\n    return (o && o.isLuxonInterval) || false;\n  }\n\n  /**\n   * Returns the start of the Interval\n   * @type {DateTime}\n   */\n  get start() {\n    return this.isValid ? this.s : null;\n  }\n\n  /**\n   * Returns the end of the Interval\n   * @type {DateTime}\n   */\n  get end() {\n    return this.isValid ? this.e : null;\n  }\n\n  /**\n   * Returns whether this Interval's end is at least its start, meaning that the Interval isn't 'backwards'.\n   * @type {boolean}\n   */\n  get isValid() {\n    return this.invalidReason === null;\n  }\n\n  /**\n   * Returns an error code if this Interval is invalid, or null if the Interval is valid\n   * @type {string}\n   */\n  get invalidReason() {\n    return this.invalid ? this.invalid.reason : null;\n  }\n\n  /**\n   * Returns an explanation of why this Interval became invalid, or null if the Interval is valid\n   * @type {string}\n   */\n  get invalidExplanation() {\n    return this.invalid ? this.invalid.explanation : null;\n  }\n\n  /**\n   * Returns the length of the Interval in the specified unit.\n   * @param {string} unit - the unit (such as 'hours' or 'days') to return the length in.\n   * @return {number}\n   */\n  length(unit = \"milliseconds\") {\n    return this.isValid ? this.toDuration(...[unit]).get(unit) : NaN;\n  }\n\n  /**\n   * Returns the count of minutes, hours, days, months, or years included in the Interval, even in part.\n   * Unlike {@link length} this counts sections of the calendar, not periods of time, e.g. specifying 'day'\n   * asks 'what dates are included in this interval?', not 'how many days long is this interval?'\n   * @param {string} [unit='milliseconds'] - the unit of time to count.\n   * @return {number}\n   */\n  count(unit = \"milliseconds\") {\n    if (!this.isValid) return NaN;\n    const start = this.start.startOf(unit),\n      end = this.end.startOf(unit);\n    return Math.floor(end.diff(start, unit).get(unit)) + 1;\n  }\n\n  /**\n   * Returns whether this Interval's start and end are both in the same unit of time\n   * @param {string} unit - the unit of time to check sameness on\n   * @return {boolean}\n   */\n  hasSame(unit) {\n    return this.isValid ? this.isEmpty() || this.e.minus(1).hasSame(this.s, unit) : false;\n  }\n\n  /**\n   * Return whether this Interval has the same start and end DateTimes.\n   * @return {boolean}\n   */\n  isEmpty() {\n    return this.s.valueOf() === this.e.valueOf();\n  }\n\n  /**\n   * Return whether this Interval's start is after the specified DateTime.\n   * @param {DateTime} dateTime\n   * @return {boolean}\n   */\n  isAfter(dateTime) {\n    if (!this.isValid) return false;\n    return this.s > dateTime;\n  }\n\n  /**\n   * Return whether this Interval's end is before the specified DateTime.\n   * @param {DateTime} dateTime\n   * @return {boolean}\n   */\n  isBefore(dateTime) {\n    if (!this.isValid) return false;\n    return this.e <= dateTime;\n  }\n\n  /**\n   * Return whether this Interval contains the specified DateTime.\n   * @param {DateTime} dateTime\n   * @return {boolean}\n   */\n  contains(dateTime) {\n    if (!this.isValid) return false;\n    return this.s <= dateTime && this.e > dateTime;\n  }\n\n  /**\n   * \"Sets\" the start and/or end dates. Returns a newly-constructed Interval.\n   * @param {Object} values - the values to set\n   * @param {DateTime} values.start - the starting DateTime\n   * @param {DateTime} values.end - the ending DateTime\n   * @return {Interval}\n   */\n  set({ start, end } = {}) {\n    if (!this.isValid) return this;\n    return Interval.fromDateTimes(start || this.s, end || this.e);\n  }\n\n  /**\n   * Split this Interval at each of the specified DateTimes\n   * @param {...[DateTime]} dateTimes - the unit of time to count.\n   * @return {[Interval]}\n   */\n  splitAt(...dateTimes) {\n    if (!this.isValid) return [];\n    const sorted = dateTimes\n        .map(friendlyDateTime)\n        .filter(d => this.contains(d))\n        .sort(),\n      results = [];\n    let { s } = this,\n      i = 0;\n\n    while (s < this.e) {\n      const added = sorted[i] || this.e,\n        next = +added > +this.e ? this.e : added;\n      results.push(Interval.fromDateTimes(s, next));\n      s = next;\n      i += 1;\n    }\n\n    return results;\n  }\n\n  /**\n   * Split this Interval into smaller Intervals, each of the specified length.\n   * Left over time is grouped into a smaller interval\n   * @param {Duration|Object|number} duration - The length of each resulting interval.\n   * @return {[Interval]}\n   */\n  splitBy(duration) {\n    const dur = friendlyDuration(duration);\n\n    if (!this.isValid || !dur.isValid || dur.as(\"milliseconds\") === 0) {\n      return [];\n    }\n\n    let { s } = this,\n      added,\n      next;\n\n    const results = [];\n    while (s < this.e) {\n      added = s.plus(dur);\n      next = +added > +this.e ? this.e : added;\n      results.push(Interval.fromDateTimes(s, next));\n      s = next;\n    }\n\n    return results;\n  }\n\n  /**\n   * Split this Interval into the specified number of smaller intervals.\n   * @param {number} numberOfParts - The number of Intervals to divide the Interval into.\n   * @return {[Interval]}\n   */\n  divideEqually(numberOfParts) {\n    if (!this.isValid) return [];\n    return this.splitBy(this.length() / numberOfParts).slice(0, numberOfParts);\n  }\n\n  /**\n   * Return whether this Interval overlaps with the specified Interval\n   * @param {Interval} other\n   * @return {boolean}\n   */\n  overlaps(other) {\n    return this.e > other.s && this.s < other.e;\n  }\n\n  /**\n   * Return whether this Interval's end is adjacent to the specified Interval's start.\n   * @param {Interval} other\n   * @return {boolean}\n   */\n  abutsStart(other) {\n    if (!this.isValid) return false;\n    return +this.e === +other.s;\n  }\n\n  /**\n   * Return whether this Interval's start is adjacent to the specified Interval's end.\n   * @param {Interval} other\n   * @return {boolean}\n   */\n  abutsEnd(other) {\n    if (!this.isValid) return false;\n    return +other.e === +this.s;\n  }\n\n  /**\n   * Return whether this Interval engulfs the start and end of the specified Interval.\n   * @param {Interval} other\n   * @return {boolean}\n   */\n  engulfs(other) {\n    if (!this.isValid) return false;\n    return this.s <= other.s && this.e >= other.e;\n  }\n\n  /**\n   * Return whether this Interval has the same start and end as the specified Interval.\n   * @param {Interval} other\n   * @return {boolean}\n   */\n  equals(other) {\n    if (!this.isValid || !other.isValid) {\n      return false;\n    }\n\n    return this.s.equals(other.s) && this.e.equals(other.e);\n  }\n\n  /**\n   * Return an Interval representing the intersection of this Interval and the specified Interval.\n   * Specifically, the resulting Interval has the maximum start time and the minimum end time of the two Intervals.\n   * Returns null if the intersection is empty, meaning, the intervals don't intersect.\n   * @param {Interval} other\n   * @return {Interval}\n   */\n  intersection(other) {\n    if (!this.isValid) return this;\n    const s = this.s > other.s ? this.s : other.s,\n      e = this.e < other.e ? this.e : other.e;\n\n    if (s > e) {\n      return null;\n    } else {\n      return Interval.fromDateTimes(s, e);\n    }\n  }\n\n  /**\n   * Return an Interval representing the union of this Interval and the specified Interval.\n   * Specifically, the resulting Interval has the minimum start time and the maximum end time of the two Intervals.\n   * @param {Interval} other\n   * @return {Interval}\n   */\n  union(other) {\n    if (!this.isValid) return this;\n    const s = this.s < other.s ? this.s : other.s,\n      e = this.e > other.e ? this.e : other.e;\n    return Interval.fromDateTimes(s, e);\n  }\n\n  /**\n   * Merge an array of Intervals into a equivalent minimal set of Intervals.\n   * Combines overlapping and adjacent Intervals.\n   * @param {[Interval]} intervals\n   * @return {[Interval]}\n   */\n  static merge(intervals) {\n    const [found, final] = intervals.sort((a, b) => a.s - b.s).reduce(\n      ([sofar, current], item) => {\n        if (!current) {\n          return [sofar, item];\n        } else if (current.overlaps(item) || current.abutsStart(item)) {\n          return [sofar, current.union(item)];\n        } else {\n          return [sofar.concat([current]), item];\n        }\n      },\n      [[], null]\n    );\n    if (final) {\n      found.push(final);\n    }\n    return found;\n  }\n\n  /**\n   * Return an array of Intervals representing the spans of time that only appear in one of the specified Intervals.\n   * @param {[Interval]} intervals\n   * @return {[Interval]}\n   */\n  static xor(intervals) {\n    let start = null,\n      currentCount = 0;\n    const results = [],\n      ends = intervals.map(i => [{ time: i.s, type: \"s\" }, { time: i.e, type: \"e\" }]),\n      flattened = Array.prototype.concat(...ends),\n      arr = flattened.sort((a, b) => a.time - b.time);\n\n    for (const i of arr) {\n      currentCount += i.type === \"s\" ? 1 : -1;\n\n      if (currentCount === 1) {\n        start = i.time;\n      } else {\n        if (start && +start !== +i.time) {\n          results.push(Interval.fromDateTimes(start, i.time));\n        }\n\n        start = null;\n      }\n    }\n\n    return Interval.merge(results);\n  }\n\n  /**\n   * Return an Interval representing the span of time in this Interval that doesn't overlap with any of the specified Intervals.\n   * @param {...Interval} intervals\n   * @return {[Interval]}\n   */\n  difference(...intervals) {\n    return Interval.xor([this].concat(intervals))\n      .map(i => this.intersection(i))\n      .filter(i => i && !i.isEmpty());\n  }\n\n  /**\n   * Returns a string representation of this Interval appropriate for debugging.\n   * @return {string}\n   */\n  toString() {\n    if (!this.isValid) return INVALID;\n    return `[${this.s.toISO()} – ${this.e.toISO()})`;\n  }\n\n  /**\n   * Returns an ISO 8601-compliant string representation of this Interval.\n   * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals\n   * @param {Object} opts - The same options as {@link DateTime.toISO}\n   * @return {string}\n   */\n  toISO(opts) {\n    if (!this.isValid) return INVALID;\n    return `${this.s.toISO(opts)}/${this.e.toISO(opts)}`;\n  }\n\n  /**\n   * Returns an ISO 8601-compliant string representation of date of this Interval.\n   * The time components are ignored.\n   * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals\n   * @return {string}\n   */\n  toISODate() {\n    if (!this.isValid) return INVALID;\n    return `${this.s.toISODate()}/${this.e.toISODate()}`;\n  }\n\n  /**\n   * Returns an ISO 8601-compliant string representation of time of this Interval.\n   * The date components are ignored.\n   * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals\n   * @param {Object} opts - The same options as {@link DateTime.toISO}\n   * @return {string}\n   */\n  toISOTime(opts) {\n    if (!this.isValid) return INVALID;\n    return `${this.s.toISOTime(opts)}/${this.e.toISOTime(opts)}`;\n  }\n\n  /**\n   * Returns a string representation of this Interval formatted according to the specified format string.\n   * @param {string} dateFormat - the format string. This string formats the start and end time. See {@link DateTime.toFormat} for details.\n   * @param {Object} opts - options\n   * @param {string} [opts.separator =  ' – '] - a separator to place between the start and end representations\n   * @return {string}\n   */\n  toFormat(dateFormat, { separator = \" – \" } = {}) {\n    if (!this.isValid) return INVALID;\n    return `${this.s.toFormat(dateFormat)}${separator}${this.e.toFormat(dateFormat)}`;\n  }\n\n  /**\n   * Return a Duration representing the time spanned by this interval.\n   * @param {string|string[]} [unit=['milliseconds']] - the unit or units (such as 'hours' or 'days') to include in the duration.\n   * @param {Object} opts - options that affect the creation of the Duration\n   * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use\n   * @example Interval.fromDateTimes(dt1, dt2).toDuration().toObject() //=> { milliseconds: 88489257 }\n   * @example Interval.fromDateTimes(dt1, dt2).toDuration('days').toObject() //=> { days: 1.0241812152777778 }\n   * @example Interval.fromDateTimes(dt1, dt2).toDuration(['hours', 'minutes']).toObject() //=> { hours: 24, minutes: 34.82095 }\n   * @example Interval.fromDateTimes(dt1, dt2).toDuration(['hours', 'minutes', 'seconds']).toObject() //=> { hours: 24, minutes: 34, seconds: 49.257 }\n   * @example Interval.fromDateTimes(dt1, dt2).toDuration('seconds').toObject() //=> { seconds: 88489.257 }\n   * @return {Duration}\n   */\n  toDuration(unit, opts) {\n    if (!this.isValid) {\n      return Duration.invalid(this.invalidReason);\n    }\n    return this.e.diff(this.s, unit, opts);\n  }\n\n  /**\n   * Run mapFn on the interval start and end, returning a new Interval from the resulting DateTimes\n   * @param {function} mapFn\n   * @return {Interval}\n   * @example Interval.fromDateTimes(dt1, dt2).mapEndpoints(endpoint => endpoint.toUTC())\n   * @example Interval.fromDateTimes(dt1, dt2).mapEndpoints(endpoint => endpoint.plus({ hours: 2 }))\n   */\n  mapEndpoints(mapFn) {\n    return Interval.fromDateTimes(mapFn(this.s), mapFn(this.e));\n  }\n}\n"]},"metadata":{},"sourceType":"module"}