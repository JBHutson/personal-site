{"ast":null,"code":"import _classCallCheck from \"/Users/jameshutson/Code/jameshutson_v2.0/personal-site/react-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/jameshutson/Code/jameshutson_v2.0/personal-site/react-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport DateTime from \"./datetime.js\";\nimport Settings from \"./settings.js\";\nimport Locale from \"./impl/locale.js\";\nimport IANAZone from \"./zones/IANAZone.js\";\nimport { normalizeZone as _normalizeZone } from \"./impl/zoneUtil.js\";\nimport { hasFormatToParts, hasIntl, hasRelative } from \"./impl/util.js\";\n/**\n * The Info class contains static methods for retrieving general time and date related data. For example, it has methods for finding out if a time zone has a DST, for listing the months in any supported locale, and for discovering which of Luxon features are available in the current environment.\n */\n\nvar Info = /*#__PURE__*/function () {\n  function Info() {\n    _classCallCheck(this, Info);\n  }\n\n  _createClass(Info, null, [{\n    key: \"hasDST\",\n\n    /**\n     * Return whether the specified zone contains a DST.\n     * @param {string|Zone} [zone='local'] - Zone to check. Defaults to the environment's local zone.\n     * @return {boolean}\n     */\n    value: function hasDST() {\n      var zone = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Settings.defaultZone;\n      var proto = DateTime.local().setZone(zone).set({\n        month: 12\n      });\n      return !zone.universal && proto.offset !== proto.set({\n        month: 6\n      }).offset;\n    }\n    /**\n     * Return whether the specified zone is a valid IANA specifier.\n     * @param {string} zone - Zone to check\n     * @return {boolean}\n     */\n\n  }, {\n    key: \"isValidIANAZone\",\n    value: function isValidIANAZone(zone) {\n      return IANAZone.isValidSpecifier(zone) && IANAZone.isValidZone(zone);\n    }\n    /**\n     * Converts the input into a {@link Zone} instance.\n     *\n     * * If `input` is already a Zone instance, it is returned unchanged.\n     * * If `input` is a string containing a valid time zone name, a Zone instance\n     *   with that name is returned.\n     * * If `input` is a string that doesn't refer to a known time zone, a Zone\n     *   instance with {@link Zone.isValid} == false is returned.\n     * * If `input is a number, a Zone instance with the specified fixed offset\n     *   in minutes is returned.\n     * * If `input` is `null` or `undefined`, the default zone is returned.\n     * @param {string|Zone|number} [input] - the value to be converted\n     * @return {Zone}\n     */\n\n  }, {\n    key: \"normalizeZone\",\n    value: function normalizeZone(input) {\n      return _normalizeZone(input, Settings.defaultZone);\n    }\n    /**\n     * Return an array of standalone month names.\n     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat\n     * @param {string} [length='long'] - the length of the month representation, such as \"numeric\", \"2-digit\", \"narrow\", \"short\", \"long\"\n     * @param {Object} opts - options\n     * @param {string} [opts.locale] - the locale code\n     * @param {string} [opts.numberingSystem=null] - the numbering system\n     * @param {string} [opts.outputCalendar='gregory'] - the calendar\n     * @example Info.months()[0] //=> 'January'\n     * @example Info.months('short')[0] //=> 'Jan'\n     * @example Info.months('numeric')[0] //=> '1'\n     * @example Info.months('short', { locale: 'fr-CA' } )[0] //=> 'janv.'\n     * @example Info.months('numeric', { locale: 'ar' })[0] //=> '١'\n     * @example Info.months('long', { outputCalendar: 'islamic' })[0] //=> 'Rabiʻ I'\n     * @return {[string]}\n     */\n\n  }, {\n    key: \"months\",\n    value: function months() {\n      var length = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"long\";\n\n      var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n          _ref$locale = _ref.locale,\n          locale = _ref$locale === void 0 ? null : _ref$locale,\n          _ref$numberingSystem = _ref.numberingSystem,\n          numberingSystem = _ref$numberingSystem === void 0 ? null : _ref$numberingSystem,\n          _ref$outputCalendar = _ref.outputCalendar,\n          outputCalendar = _ref$outputCalendar === void 0 ? \"gregory\" : _ref$outputCalendar;\n\n      return Locale.create(locale, numberingSystem, outputCalendar).months(length);\n    }\n    /**\n     * Return an array of format month names.\n     * Format months differ from standalone months in that they're meant to appear next to the day of the month. In some languages, that\n     * changes the string.\n     * See {@link months}\n     * @param {string} [length='long'] - the length of the month representation, such as \"numeric\", \"2-digit\", \"narrow\", \"short\", \"long\"\n     * @param {Object} opts - options\n     * @param {string} [opts.locale] - the locale code\n     * @param {string} [opts.numberingSystem=null] - the numbering system\n     * @param {string} [opts.outputCalendar='gregory'] - the calendar\n     * @return {[string]}\n     */\n\n  }, {\n    key: \"monthsFormat\",\n    value: function monthsFormat() {\n      var length = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"long\";\n\n      var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n          _ref2$locale = _ref2.locale,\n          locale = _ref2$locale === void 0 ? null : _ref2$locale,\n          _ref2$numberingSystem = _ref2.numberingSystem,\n          numberingSystem = _ref2$numberingSystem === void 0 ? null : _ref2$numberingSystem,\n          _ref2$outputCalendar = _ref2.outputCalendar,\n          outputCalendar = _ref2$outputCalendar === void 0 ? \"gregory\" : _ref2$outputCalendar;\n\n      return Locale.create(locale, numberingSystem, outputCalendar).months(length, true);\n    }\n    /**\n     * Return an array of standalone week names.\n     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat\n     * @param {string} [length='long'] - the length of the weekday representation, such as \"narrow\", \"short\", \"long\".\n     * @param {Object} opts - options\n     * @param {string} [opts.locale] - the locale code\n     * @param {string} [opts.numberingSystem=null] - the numbering system\n     * @example Info.weekdays()[0] //=> 'Monday'\n     * @example Info.weekdays('short')[0] //=> 'Mon'\n     * @example Info.weekdays('short', { locale: 'fr-CA' })[0] //=> 'lun.'\n     * @example Info.weekdays('short', { locale: 'ar' })[0] //=> 'الاثنين'\n     * @return {[string]}\n     */\n\n  }, {\n    key: \"weekdays\",\n    value: function weekdays() {\n      var length = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"long\";\n\n      var _ref3 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n          _ref3$locale = _ref3.locale,\n          locale = _ref3$locale === void 0 ? null : _ref3$locale,\n          _ref3$numberingSystem = _ref3.numberingSystem,\n          numberingSystem = _ref3$numberingSystem === void 0 ? null : _ref3$numberingSystem;\n\n      return Locale.create(locale, numberingSystem, null).weekdays(length);\n    }\n    /**\n     * Return an array of format week names.\n     * Format weekdays differ from standalone weekdays in that they're meant to appear next to more date information. In some languages, that\n     * changes the string.\n     * See {@link weekdays}\n     * @param {string} [length='long'] - the length of the weekday representation, such as \"narrow\", \"short\", \"long\".\n     * @param {Object} opts - options\n     * @param {string} [opts.locale=null] - the locale code\n     * @param {string} [opts.numberingSystem=null] - the numbering system\n     * @return {[string]}\n     */\n\n  }, {\n    key: \"weekdaysFormat\",\n    value: function weekdaysFormat() {\n      var length = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"long\";\n\n      var _ref4 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n          _ref4$locale = _ref4.locale,\n          locale = _ref4$locale === void 0 ? null : _ref4$locale,\n          _ref4$numberingSystem = _ref4.numberingSystem,\n          numberingSystem = _ref4$numberingSystem === void 0 ? null : _ref4$numberingSystem;\n\n      return Locale.create(locale, numberingSystem, null).weekdays(length, true);\n    }\n    /**\n     * Return an array of meridiems.\n     * @param {Object} opts - options\n     * @param {string} [opts.locale] - the locale code\n     * @example Info.meridiems() //=> [ 'AM', 'PM' ]\n     * @example Info.meridiems({ locale: 'my' }) //=> [ 'နံနက်', 'ညနေ' ]\n     * @return {[string]}\n     */\n\n  }, {\n    key: \"meridiems\",\n    value: function meridiems() {\n      var _ref5 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          _ref5$locale = _ref5.locale,\n          locale = _ref5$locale === void 0 ? null : _ref5$locale;\n\n      return Locale.create(locale).meridiems();\n    }\n    /**\n     * Return an array of eras, such as ['BC', 'AD']. The locale can be specified, but the calendar system is always Gregorian.\n     * @param {string} [length='short'] - the length of the era representation, such as \"short\" or \"long\".\n     * @param {Object} opts - options\n     * @param {string} [opts.locale] - the locale code\n     * @example Info.eras() //=> [ 'BC', 'AD' ]\n     * @example Info.eras('long') //=> [ 'Before Christ', 'Anno Domini' ]\n     * @example Info.eras('long', { locale: 'fr' }) //=> [ 'avant Jésus-Christ', 'après Jésus-Christ' ]\n     * @return {[string]}\n     */\n\n  }, {\n    key: \"eras\",\n    value: function eras() {\n      var length = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"short\";\n\n      var _ref6 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n          _ref6$locale = _ref6.locale,\n          locale = _ref6$locale === void 0 ? null : _ref6$locale;\n\n      return Locale.create(locale, null, \"gregory\").eras(length);\n    }\n    /**\n     * Return the set of available features in this environment.\n     * Some features of Luxon are not available in all environments. For example, on older browsers, timezone support is not available. Use this function to figure out if that's the case.\n     * Keys:\n     * * `zones`: whether this environment supports IANA timezones\n     * * `intlTokens`: whether this environment supports internationalized token-based formatting/parsing\n     * * `intl`: whether this environment supports general internationalization\n     * * `relative`: whether this environment supports relative time formatting\n     * @example Info.features() //=> { intl: true, intlTokens: false, zones: true, relative: false }\n     * @return {Object}\n     */\n\n  }, {\n    key: \"features\",\n    value: function features() {\n      var intl = false,\n          intlTokens = false,\n          zones = false,\n          relative = false;\n\n      if (hasIntl()) {\n        intl = true;\n        intlTokens = hasFormatToParts();\n        relative = hasRelative();\n\n        try {\n          zones = new Intl.DateTimeFormat(\"en\", {\n            timeZone: \"America/New_York\"\n          }).resolvedOptions().timeZone === \"America/New_York\";\n        } catch (e) {\n          zones = false;\n        }\n      }\n\n      return {\n        intl: intl,\n        intlTokens: intlTokens,\n        zones: zones,\n        relative: relative\n      };\n    }\n  }]);\n\n  return Info;\n}();\n\nexport { Info as default };","map":{"version":3,"sources":["/Users/jameshutson/Code/jameshutson_v2.0/personal-site/react-frontend/node_modules/luxon/src/info.js"],"names":["DateTime","Settings","Locale","IANAZone","normalizeZone","hasFormatToParts","hasIntl","hasRelative","Info","zone","defaultZone","proto","local","setZone","set","month","universal","offset","isValidSpecifier","isValidZone","input","length","locale","numberingSystem","outputCalendar","create","months","weekdays","meridiems","eras","intl","intlTokens","zones","relative","Intl","DateTimeFormat","timeZone","resolvedOptions","e"],"mappings":"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","sourcesContent":["import DateTime from \"./datetime.js\";\nimport Settings from \"./settings.js\";\nimport Locale from \"./impl/locale.js\";\nimport IANAZone from \"./zones/IANAZone.js\";\nimport { normalizeZone } from \"./impl/zoneUtil.js\";\n\nimport { hasFormatToParts, hasIntl, hasRelative } from \"./impl/util.js\";\n\n/**\n * The Info class contains static methods for retrieving general time and date related data. For example, it has methods for finding out if a time zone has a DST, for listing the months in any supported locale, and for discovering which of Luxon features are available in the current environment.\n */\nexport default class Info {\n  /**\n   * Return whether the specified zone contains a DST.\n   * @param {string|Zone} [zone='local'] - Zone to check. Defaults to the environment's local zone.\n   * @return {boolean}\n   */\n  static hasDST(zone = Settings.defaultZone) {\n    const proto = DateTime.local()\n      .setZone(zone)\n      .set({ month: 12 });\n\n    return !zone.universal && proto.offset !== proto.set({ month: 6 }).offset;\n  }\n\n  /**\n   * Return whether the specified zone is a valid IANA specifier.\n   * @param {string} zone - Zone to check\n   * @return {boolean}\n   */\n  static isValidIANAZone(zone) {\n    return IANAZone.isValidSpecifier(zone) && IANAZone.isValidZone(zone);\n  }\n\n  /**\n   * Converts the input into a {@link Zone} instance.\n   *\n   * * If `input` is already a Zone instance, it is returned unchanged.\n   * * If `input` is a string containing a valid time zone name, a Zone instance\n   *   with that name is returned.\n   * * If `input` is a string that doesn't refer to a known time zone, a Zone\n   *   instance with {@link Zone.isValid} == false is returned.\n   * * If `input is a number, a Zone instance with the specified fixed offset\n   *   in minutes is returned.\n   * * If `input` is `null` or `undefined`, the default zone is returned.\n   * @param {string|Zone|number} [input] - the value to be converted\n   * @return {Zone}\n   */\n  static normalizeZone(input) {\n    return normalizeZone(input, Settings.defaultZone);\n  }\n\n  /**\n   * Return an array of standalone month names.\n   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat\n   * @param {string} [length='long'] - the length of the month representation, such as \"numeric\", \"2-digit\", \"narrow\", \"short\", \"long\"\n   * @param {Object} opts - options\n   * @param {string} [opts.locale] - the locale code\n   * @param {string} [opts.numberingSystem=null] - the numbering system\n   * @param {string} [opts.outputCalendar='gregory'] - the calendar\n   * @example Info.months()[0] //=> 'January'\n   * @example Info.months('short')[0] //=> 'Jan'\n   * @example Info.months('numeric')[0] //=> '1'\n   * @example Info.months('short', { locale: 'fr-CA' } )[0] //=> 'janv.'\n   * @example Info.months('numeric', { locale: 'ar' })[0] //=> '١'\n   * @example Info.months('long', { outputCalendar: 'islamic' })[0] //=> 'Rabiʻ I'\n   * @return {[string]}\n   */\n  static months(\n    length = \"long\",\n    { locale = null, numberingSystem = null, outputCalendar = \"gregory\" } = {}\n  ) {\n    return Locale.create(locale, numberingSystem, outputCalendar).months(length);\n  }\n\n  /**\n   * Return an array of format month names.\n   * Format months differ from standalone months in that they're meant to appear next to the day of the month. In some languages, that\n   * changes the string.\n   * See {@link months}\n   * @param {string} [length='long'] - the length of the month representation, such as \"numeric\", \"2-digit\", \"narrow\", \"short\", \"long\"\n   * @param {Object} opts - options\n   * @param {string} [opts.locale] - the locale code\n   * @param {string} [opts.numberingSystem=null] - the numbering system\n   * @param {string} [opts.outputCalendar='gregory'] - the calendar\n   * @return {[string]}\n   */\n  static monthsFormat(\n    length = \"long\",\n    { locale = null, numberingSystem = null, outputCalendar = \"gregory\" } = {}\n  ) {\n    return Locale.create(locale, numberingSystem, outputCalendar).months(length, true);\n  }\n\n  /**\n   * Return an array of standalone week names.\n   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat\n   * @param {string} [length='long'] - the length of the weekday representation, such as \"narrow\", \"short\", \"long\".\n   * @param {Object} opts - options\n   * @param {string} [opts.locale] - the locale code\n   * @param {string} [opts.numberingSystem=null] - the numbering system\n   * @example Info.weekdays()[0] //=> 'Monday'\n   * @example Info.weekdays('short')[0] //=> 'Mon'\n   * @example Info.weekdays('short', { locale: 'fr-CA' })[0] //=> 'lun.'\n   * @example Info.weekdays('short', { locale: 'ar' })[0] //=> 'الاثنين'\n   * @return {[string]}\n   */\n  static weekdays(length = \"long\", { locale = null, numberingSystem = null } = {}) {\n    return Locale.create(locale, numberingSystem, null).weekdays(length);\n  }\n\n  /**\n   * Return an array of format week names.\n   * Format weekdays differ from standalone weekdays in that they're meant to appear next to more date information. In some languages, that\n   * changes the string.\n   * See {@link weekdays}\n   * @param {string} [length='long'] - the length of the weekday representation, such as \"narrow\", \"short\", \"long\".\n   * @param {Object} opts - options\n   * @param {string} [opts.locale=null] - the locale code\n   * @param {string} [opts.numberingSystem=null] - the numbering system\n   * @return {[string]}\n   */\n  static weekdaysFormat(length = \"long\", { locale = null, numberingSystem = null } = {}) {\n    return Locale.create(locale, numberingSystem, null).weekdays(length, true);\n  }\n\n  /**\n   * Return an array of meridiems.\n   * @param {Object} opts - options\n   * @param {string} [opts.locale] - the locale code\n   * @example Info.meridiems() //=> [ 'AM', 'PM' ]\n   * @example Info.meridiems({ locale: 'my' }) //=> [ 'နံနက်', 'ညနေ' ]\n   * @return {[string]}\n   */\n  static meridiems({ locale = null } = {}) {\n    return Locale.create(locale).meridiems();\n  }\n\n  /**\n   * Return an array of eras, such as ['BC', 'AD']. The locale can be specified, but the calendar system is always Gregorian.\n   * @param {string} [length='short'] - the length of the era representation, such as \"short\" or \"long\".\n   * @param {Object} opts - options\n   * @param {string} [opts.locale] - the locale code\n   * @example Info.eras() //=> [ 'BC', 'AD' ]\n   * @example Info.eras('long') //=> [ 'Before Christ', 'Anno Domini' ]\n   * @example Info.eras('long', { locale: 'fr' }) //=> [ 'avant Jésus-Christ', 'après Jésus-Christ' ]\n   * @return {[string]}\n   */\n  static eras(length = \"short\", { locale = null } = {}) {\n    return Locale.create(locale, null, \"gregory\").eras(length);\n  }\n\n  /**\n   * Return the set of available features in this environment.\n   * Some features of Luxon are not available in all environments. For example, on older browsers, timezone support is not available. Use this function to figure out if that's the case.\n   * Keys:\n   * * `zones`: whether this environment supports IANA timezones\n   * * `intlTokens`: whether this environment supports internationalized token-based formatting/parsing\n   * * `intl`: whether this environment supports general internationalization\n   * * `relative`: whether this environment supports relative time formatting\n   * @example Info.features() //=> { intl: true, intlTokens: false, zones: true, relative: false }\n   * @return {Object}\n   */\n  static features() {\n    let intl = false,\n      intlTokens = false,\n      zones = false,\n      relative = false;\n\n    if (hasIntl()) {\n      intl = true;\n      intlTokens = hasFormatToParts();\n      relative = hasRelative();\n\n      try {\n        zones =\n          new Intl.DateTimeFormat(\"en\", { timeZone: \"America/New_York\" }).resolvedOptions()\n            .timeZone === \"America/New_York\";\n      } catch (e) {\n        zones = false;\n      }\n    }\n\n    return { intl, intlTokens, zones, relative };\n  }\n}\n"]},"metadata":{},"sourceType":"module"}