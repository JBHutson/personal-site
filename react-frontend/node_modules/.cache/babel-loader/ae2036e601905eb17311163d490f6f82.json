{"ast":null,"code":"import _classCallCheck from \"/Users/jameshutson/Code/jameshutson_v2.0/personal-site/react-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/jameshutson/Code/jameshutson_v2.0/personal-site/react-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _inherits from \"/Users/jameshutson/Code/jameshutson_v2.0/personal-site/react-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Users/jameshutson/Code/jameshutson_v2.0/personal-site/react-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport _slicedToArray from \"/Users/jameshutson/Code/jameshutson_v2.0/personal-site/react-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport { formatOffset as _formatOffset, parseZoneInfo, isUndefined, ianaRegex, objToLocalTS } from \"../impl/util.js\";\nimport Zone from \"../zone.js\";\nvar matchingRegex = RegExp(\"^\".concat(ianaRegex.source, \"$\"));\nvar dtfCache = {};\n\nfunction makeDTF(zone) {\n  if (!dtfCache[zone]) {\n    dtfCache[zone] = new Intl.DateTimeFormat(\"en-US\", {\n      hour12: false,\n      timeZone: zone,\n      year: \"numeric\",\n      month: \"2-digit\",\n      day: \"2-digit\",\n      hour: \"2-digit\",\n      minute: \"2-digit\",\n      second: \"2-digit\"\n    });\n  }\n\n  return dtfCache[zone];\n}\n\nvar typeToPos = {\n  year: 0,\n  month: 1,\n  day: 2,\n  hour: 3,\n  minute: 4,\n  second: 5\n};\n\nfunction hackyOffset(dtf, date) {\n  var formatted = dtf.format(date).replace(/\\u200E/g, \"\"),\n      parsed = /(\\d+)\\/(\\d+)\\/(\\d+),? (\\d+):(\\d+):(\\d+)/.exec(formatted),\n      _parsed = _slicedToArray(parsed, 7),\n      fMonth = _parsed[1],\n      fDay = _parsed[2],\n      fYear = _parsed[3],\n      fHour = _parsed[4],\n      fMinute = _parsed[5],\n      fSecond = _parsed[6];\n\n  return [fYear, fMonth, fDay, fHour, fMinute, fSecond];\n}\n\nfunction partsOffset(dtf, date) {\n  var formatted = dtf.formatToParts(date),\n      filled = [];\n\n  for (var i = 0; i < formatted.length; i++) {\n    var _formatted$i = formatted[i],\n        type = _formatted$i.type,\n        value = _formatted$i.value,\n        pos = typeToPos[type];\n\n    if (!isUndefined(pos)) {\n      filled[pos] = parseInt(value, 10);\n    }\n  }\n\n  return filled;\n}\n\nvar ianaZoneCache = {};\n/**\n * A zone identified by an IANA identifier, like America/New_York\n * @implements {Zone}\n */\n\nvar IANAZone = /*#__PURE__*/function (_Zone) {\n  _inherits(IANAZone, _Zone);\n\n  var _super = _createSuper(IANAZone);\n\n  _createClass(IANAZone, null, [{\n    key: \"create\",\n\n    /**\n     * @param {string} name - Zone name\n     * @return {IANAZone}\n     */\n    value: function create(name) {\n      if (!ianaZoneCache[name]) {\n        ianaZoneCache[name] = new IANAZone(name);\n      }\n\n      return ianaZoneCache[name];\n    }\n    /**\n     * Reset local caches. Should only be necessary in testing scenarios.\n     * @return {void}\n     */\n\n  }, {\n    key: \"resetCache\",\n    value: function resetCache() {\n      ianaZoneCache = {};\n      dtfCache = {};\n    }\n    /**\n     * Returns whether the provided string is a valid specifier. This only checks the string's format, not that the specifier identifies a known zone; see isValidZone for that.\n     * @param {string} s - The string to check validity on\n     * @example IANAZone.isValidSpecifier(\"America/New_York\") //=> true\n     * @example IANAZone.isValidSpecifier(\"Fantasia/Castle\") //=> true\n     * @example IANAZone.isValidSpecifier(\"Sport~~blorp\") //=> false\n     * @return {boolean}\n     */\n\n  }, {\n    key: \"isValidSpecifier\",\n    value: function isValidSpecifier(s) {\n      return !!(s && s.match(matchingRegex));\n    }\n    /**\n     * Returns whether the provided string identifies a real zone\n     * @param {string} zone - The string to check\n     * @example IANAZone.isValidZone(\"America/New_York\") //=> true\n     * @example IANAZone.isValidZone(\"Fantasia/Castle\") //=> false\n     * @example IANAZone.isValidZone(\"Sport~~blorp\") //=> false\n     * @return {boolean}\n     */\n\n  }, {\n    key: \"isValidZone\",\n    value: function isValidZone(zone) {\n      try {\n        new Intl.DateTimeFormat(\"en-US\", {\n          timeZone: zone\n        }).format();\n        return true;\n      } catch (e) {\n        return false;\n      }\n    } // Etc/GMT+8 -> -480\n\n    /** @ignore */\n\n  }, {\n    key: \"parseGMTOffset\",\n    value: function parseGMTOffset(specifier) {\n      if (specifier) {\n        var match = specifier.match(/^Etc\\/GMT([+-]\\d{1,2})$/i);\n\n        if (match) {\n          return -60 * parseInt(match[1]);\n        }\n      }\n\n      return null;\n    }\n  }]);\n\n  function IANAZone(name) {\n    var _this;\n\n    _classCallCheck(this, IANAZone);\n\n    _this = _super.call(this);\n    /** @private **/\n\n    _this.zoneName = name;\n    /** @private **/\n\n    _this.valid = IANAZone.isValidZone(name);\n    return _this;\n  }\n  /** @override **/\n\n\n  _createClass(IANAZone, [{\n    key: \"offsetName\",\n\n    /** @override **/\n    value: function offsetName(ts, _ref) {\n      var format = _ref.format,\n          locale = _ref.locale;\n      return parseZoneInfo(ts, format, locale, this.name);\n    }\n    /** @override **/\n\n  }, {\n    key: \"formatOffset\",\n    value: function formatOffset(ts, format) {\n      return _formatOffset(this.offset(ts), format);\n    }\n    /** @override **/\n\n  }, {\n    key: \"offset\",\n    value: function offset(ts) {\n      var date = new Date(ts),\n          dtf = makeDTF(this.name),\n          _ref2 = dtf.formatToParts ? partsOffset(dtf, date) : hackyOffset(dtf, date),\n          _ref3 = _slicedToArray(_ref2, 6),\n          year = _ref3[0],\n          month = _ref3[1],\n          day = _ref3[2],\n          hour = _ref3[3],\n          minute = _ref3[4],\n          second = _ref3[5],\n          adjustedHour = hour === 24 ? 0 : hour;\n\n      var asUTC = objToLocalTS({\n        year: year,\n        month: month,\n        day: day,\n        hour: adjustedHour,\n        minute: minute,\n        second: second,\n        millisecond: 0\n      });\n      var asTS = +date;\n      var over = asTS % 1000;\n      asTS -= over >= 0 ? over : 1000 + over;\n      return (asUTC - asTS) / (60 * 1000);\n    }\n    /** @override **/\n\n  }, {\n    key: \"equals\",\n    value: function equals(otherZone) {\n      return otherZone.type === \"iana\" && otherZone.name === this.name;\n    }\n    /** @override **/\n\n  }, {\n    key: \"type\",\n    get: function get() {\n      return \"iana\";\n    }\n    /** @override **/\n\n  }, {\n    key: \"name\",\n    get: function get() {\n      return this.zoneName;\n    }\n    /** @override **/\n\n  }, {\n    key: \"universal\",\n    get: function get() {\n      return false;\n    }\n  }, {\n    key: \"isValid\",\n    get: function get() {\n      return this.valid;\n    }\n  }]);\n\n  return IANAZone;\n}(Zone);\n\nexport { IANAZone as default };","map":{"version":3,"sources":["/Users/jameshutson/Code/jameshutson_v2.0/personal-site/react-frontend/node_modules/luxon/src/zones/IANAZone.js"],"names":["formatOffset","parseZoneInfo","isUndefined","ianaRegex","objToLocalTS","Zone","matchingRegex","RegExp","source","dtfCache","makeDTF","zone","Intl","DateTimeFormat","hour12","timeZone","year","month","day","hour","minute","second","typeToPos","hackyOffset","dtf","date","formatted","format","replace","parsed","exec","fMonth","fDay","fYear","fHour","fMinute","fSecond","partsOffset","formatToParts","filled","i","length","type","value","pos","parseInt","ianaZoneCache","IANAZone","name","s","match","e","specifier","zoneName","valid","isValidZone","ts","locale","offset","Date","adjustedHour","asUTC","millisecond","asTS","over","otherZone"],"mappings":"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","sourcesContent":["import { formatOffset, parseZoneInfo, isUndefined, ianaRegex, objToLocalTS } from \"../impl/util.js\";\nimport Zone from \"../zone.js\";\n\nconst matchingRegex = RegExp(`^${ianaRegex.source}$`);\n\nlet dtfCache = {};\nfunction makeDTF(zone) {\n  if (!dtfCache[zone]) {\n    dtfCache[zone] = new Intl.DateTimeFormat(\"en-US\", {\n      hour12: false,\n      timeZone: zone,\n      year: \"numeric\",\n      month: \"2-digit\",\n      day: \"2-digit\",\n      hour: \"2-digit\",\n      minute: \"2-digit\",\n      second: \"2-digit\"\n    });\n  }\n  return dtfCache[zone];\n}\n\nconst typeToPos = {\n  year: 0,\n  month: 1,\n  day: 2,\n  hour: 3,\n  minute: 4,\n  second: 5\n};\n\nfunction hackyOffset(dtf, date) {\n  const formatted = dtf.format(date).replace(/\\u200E/g, \"\"),\n    parsed = /(\\d+)\\/(\\d+)\\/(\\d+),? (\\d+):(\\d+):(\\d+)/.exec(formatted),\n    [, fMonth, fDay, fYear, fHour, fMinute, fSecond] = parsed;\n  return [fYear, fMonth, fDay, fHour, fMinute, fSecond];\n}\n\nfunction partsOffset(dtf, date) {\n  const formatted = dtf.formatToParts(date),\n    filled = [];\n  for (let i = 0; i < formatted.length; i++) {\n    const { type, value } = formatted[i],\n      pos = typeToPos[type];\n\n    if (!isUndefined(pos)) {\n      filled[pos] = parseInt(value, 10);\n    }\n  }\n  return filled;\n}\n\nlet ianaZoneCache = {};\n/**\n * A zone identified by an IANA identifier, like America/New_York\n * @implements {Zone}\n */\nexport default class IANAZone extends Zone {\n  /**\n   * @param {string} name - Zone name\n   * @return {IANAZone}\n   */\n  static create(name) {\n    if (!ianaZoneCache[name]) {\n      ianaZoneCache[name] = new IANAZone(name);\n    }\n    return ianaZoneCache[name];\n  }\n\n  /**\n   * Reset local caches. Should only be necessary in testing scenarios.\n   * @return {void}\n   */\n  static resetCache() {\n    ianaZoneCache = {};\n    dtfCache = {};\n  }\n\n  /**\n   * Returns whether the provided string is a valid specifier. This only checks the string's format, not that the specifier identifies a known zone; see isValidZone for that.\n   * @param {string} s - The string to check validity on\n   * @example IANAZone.isValidSpecifier(\"America/New_York\") //=> true\n   * @example IANAZone.isValidSpecifier(\"Fantasia/Castle\") //=> true\n   * @example IANAZone.isValidSpecifier(\"Sport~~blorp\") //=> false\n   * @return {boolean}\n   */\n  static isValidSpecifier(s) {\n    return !!(s && s.match(matchingRegex));\n  }\n\n  /**\n   * Returns whether the provided string identifies a real zone\n   * @param {string} zone - The string to check\n   * @example IANAZone.isValidZone(\"America/New_York\") //=> true\n   * @example IANAZone.isValidZone(\"Fantasia/Castle\") //=> false\n   * @example IANAZone.isValidZone(\"Sport~~blorp\") //=> false\n   * @return {boolean}\n   */\n  static isValidZone(zone) {\n    try {\n      new Intl.DateTimeFormat(\"en-US\", { timeZone: zone }).format();\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }\n\n  // Etc/GMT+8 -> -480\n  /** @ignore */\n  static parseGMTOffset(specifier) {\n    if (specifier) {\n      const match = specifier.match(/^Etc\\/GMT([+-]\\d{1,2})$/i);\n      if (match) {\n        return -60 * parseInt(match[1]);\n      }\n    }\n    return null;\n  }\n\n  constructor(name) {\n    super();\n    /** @private **/\n    this.zoneName = name;\n    /** @private **/\n    this.valid = IANAZone.isValidZone(name);\n  }\n\n  /** @override **/\n  get type() {\n    return \"iana\";\n  }\n\n  /** @override **/\n  get name() {\n    return this.zoneName;\n  }\n\n  /** @override **/\n  get universal() {\n    return false;\n  }\n\n  /** @override **/\n  offsetName(ts, { format, locale }) {\n    return parseZoneInfo(ts, format, locale, this.name);\n  }\n\n  /** @override **/\n  formatOffset(ts, format) {\n    return formatOffset(this.offset(ts), format);\n  }\n\n  /** @override **/\n  offset(ts) {\n    const date = new Date(ts),\n      dtf = makeDTF(this.name),\n      [year, month, day, hour, minute, second] = dtf.formatToParts\n        ? partsOffset(dtf, date)\n        : hackyOffset(dtf, date),\n      // work around https://bugs.chromium.org/p/chromium/issues/detail?id=1025564&can=2&q=%2224%3A00%22%20datetimeformat\n      adjustedHour = hour === 24 ? 0 : hour;\n\n    const asUTC = objToLocalTS({\n      year,\n      month,\n      day,\n      hour: adjustedHour,\n      minute,\n      second,\n      millisecond: 0\n    });\n\n    let asTS = +date;\n    const over = asTS % 1000;\n    asTS -= over >= 0 ? over : 1000 + over;\n    return (asUTC - asTS) / (60 * 1000);\n  }\n\n  /** @override **/\n  equals(otherZone) {\n    return otherZone.type === \"iana\" && otherZone.name === this.name;\n  }\n\n  /** @override **/\n  get isValid() {\n    return this.valid;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}